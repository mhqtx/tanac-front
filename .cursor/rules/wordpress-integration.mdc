# WordPress Integration Guidelines

## API Data Fetching

- Use the `safeFetch` utility function for all API calls
- Always handle errors gracefully with try-catch blocks
- Use proper TypeScript types from `wp-types` package
- Cache API responses appropriately with Next.js caching strategies

## Data Fetching Pattern

```typescript
import type { WP_REST_API_Posts, WP_REST_API_Page } from "wp-types";

const safeFetch = async <T>(url: string): Promise<T | null> => {
  try {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return (await res.json()) as T;
  } catch (err) {
    console.error(`Fetch failed for ${url}:`, err);
    return null;
  }
};

// Usage example
const posts = await safeFetch<WP_REST_API_Posts>(`${baseUrl}/posts?_embed`);
```

## WordPress Data Types

- Use `WP_REST_API_Posts` for blog posts
- Use `WP_REST_API_Page` for pages
- Extend types for custom ACF fields when needed
- Handle embedded media with `_embed` parameter

## ACF Fields Integration

- Define proper TypeScript interfaces for ACF fields
- Use optional chaining for nested ACF data
- Provide fallback values for missing data
- Handle HTML content with `dangerouslySetInnerHTML` when necessary

## Image Handling

- Use Next.js `Image` component for optimized images
- Configure image domains in [next.config.ts](mdc:next.config.ts)
- Handle missing images with fallback content
- Use proper alt text for accessibility

## Environment Variables

- Use `NEXT_PUBLIC_WORDPRESS_API` for API base URL
- Keep sensitive data in server-side environment variables
- Validate environment variables on startup

## Error Handling

- Show user-friendly error messages
- Implement loading states for async operations
- Log errors for debugging purposes
- Gracefully handle network failures
  description:
  globs:
  alwaysApply: true

---
