# Performance Optimization Guidelines

## Next.js Best Practices

- Use Server Components by default for better performance
- Implement proper caching strategies for API calls
- Use `next/image` for optimized image loading
- Implement code splitting with dynamic imports
- Use proper loading states and error boundaries

## Image Optimization

```typescript
import Image from "next/image";

// Always use Next.js Image component
<Image
  src={imageUrl}
  alt="Descriptive alt text"
  width={300}
  height={200}
  priority={isAboveFold} // Use for hero images
  loading="lazy" // Default for below-fold images
/>;
```

## Data Fetching Optimization

- Use `cache: "no-store"` for dynamic data
- Use `cache: "force-cache"` for static data
- Implement revalidation with `revalidate` option
- Use ISR (Incremental Static Regeneration) when appropriate

## Component Optimization

- Use `React.memo` for expensive components
- Implement proper key props for lists
- Avoid inline object/function creation in render
- Use `useCallback` and `useMemo` judiciously

## Bundle Optimization

- Use dynamic imports for large components
- Implement proper tree shaking
- Avoid unnecessary dependencies
- Use proper import/export patterns

## Loading States

```typescript
// Implement loading states for better UX
const [isLoading, setIsLoading] = useState(true);
const [data, setData] = useState(null);

if (isLoading) {
  return <LoadingSpinner />;
}

if (!data) {
  return <ErrorMessage />;
}
```

## Error Handling

- Implement error boundaries for component errors
- Use proper error states for API failures
- Provide fallback UI for failed components
- Log errors appropriately for debugging

## SEO Optimization

- Use proper meta tags in layout
- Implement structured data where appropriate
- Use semantic HTML elements
- Optimize for Core Web Vitals
  description:
  globs:
  alwaysApply: true

---
